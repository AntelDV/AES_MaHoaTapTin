# ==============================================================================
# PHẦN 1: KHAI BÁO CÁC BẢNG VÀ HẰNG SỐ CỦA DES
# Đây là các bảng chuẩn của thuật toán DES, định nghĩa các phép biến đổi cố định.
# ==============================================================================

# Bảng hoán vị khởi tạo (Initial Permutation) - sắp xếp lại 64 bit của khối dữ liệu đầu vào.
IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]

# Bảng hoán vị kết thúc (Final Permutation) - là phép hoán vị ngược của IP. = IP -1
FP = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
      38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
      36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
      34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]

# Bảng mở rộng (Expansion) - mở rộng nửa phải 32-bit thành 48-bit để XOR với khóa con 48-bit.
E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
     8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
     16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
     24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]

# 8 bảng S-box (Substitution-boxes) - mỗi S-box nhận 6 bit và trả về 4 bit.
# Đây là thành phần phi tuyến duy nhất và là cốt lõi bảo mật của DES.
S_BOXES = [
    [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
     [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
     [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
     [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],
    # ... (các S-box khác từ S2 đến S8) ...
    [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
     [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
     [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
     [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

    [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
     [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
     [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
     [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

    [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
     [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
     [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
     [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

    [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
     [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
     [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
     [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

    [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
     [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
     [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
     [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

    [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
     [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
     [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
     [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

    [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
     [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
     [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
     [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
]

# P-box (Permutation-box) - hoán vị 32-bit đầu ra từ các S-box để tăng cường khuếch tán.
P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,
     2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]

# PC-1 (Permuted Choice 1) - Chọn và hoán vị 56 bit từ khóa chính 64-bit, loại bỏ 8 bit chẵn lẻ.
PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
       10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
       63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
       14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]

# PC-2 (Permuted Choice 2) - Nén 56 bit thành 48 bit để tạo khóa con cho mỗi vòng.
PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
       23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
       41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
       44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]

# Bảng số bit dịch vòng trái cho 16 vòng.
SHIFT_BITS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

class DES:
   def __init__(self, key):
    # khoi tao lop DES voi khoa chinh
    self.key = self._to_binary_list(key, 64) 
    self.subkeys = self._generate_subkeys()

# Tạo 1 biến key và gọi hàm binary list để chuyển key đó từ dạng byte thành 1 list chứa 64 số 0 và 1
# Tạo 1 biến subkeys dùng để lưu trữ các khóa con, với việc gọi hàm generate_key chương trình sẽ gọi hàm sinh hó con để tạo ra trước 16 khóa con cho vòng lặp






   def _to_binary_list(self, byte_data, num_bits):
    # chuyen doi du lieu bytes thanh cac bit
    bit_list = []
    for byte in byte_data:
      for i in range(7, -1, -1):
        bit_list.append((byte >> i) & 1)
    return bit_list



# khởi tạo mảng danh sách bit
# ta đi duyệt từng byte trong chuỗi byte_data đầo vào ví dụ như key=b'123' thì chạy lặp 3 lần
#  for i in range(7, -1, -1): bên trong vòng lặp trên, vòng lặp này sẽ chạy thêm 8 lần cho mỗi byte, 
       # với i sẽ đi từ 7 -> 0. điều này là để đọc 8 bit của byte qua từ trái sang phải (từ bit có trọng số cao (MSB) tới trọng số thấp (LSB))
       
# (byte >> i) & 1    : phép dịch bit phải (shift right) nó sẽ dịch các bit của byte sang phải i lần. Thao tác này sẽ đưa bit vị trí thứ i về vị trí cuối cùng
        # với &1:    thì đây là phép AND với bit 1, sau khi dịch bit ta AND kết quả với 1. Thao tác này sẽ xóa hết all các but khác và chỉ giữ lại bit cuối cung, kết quả sẽ là 1 nếu bit đó là 1, 0 thì là 0

# Thêm bit (0 hoặc 1) vừa lấy được đưa vào bit_list











   def _from_binary_list(self, bit_list):   # Hàm chuển đổi ngược list về byte
    byte_data = []
    for i in range(0, len(bit_list), 8):
      byte = 0
      for j in range (8):
        byte = (byte << 1) | bit_list[i+j]
      byte_data.append(byte)
    return bytes(byte_data)



# Tạo 1 mạng byte_data
# duyệt qua từng bit_list theo từng khối 8bit (từng byte) với i là  0, 8, 16
# tạo biến byte cho nó bằng 0
# duyệt qua 8bit trong các khối hiện tại
# byte << 1)  sử dụng phép dịch trái , dịch các bit của byte hiện tại sang trái 1 vị trí, tạo ra 1 không gian trống ở bit cuối
# | bit_list[i+j áp dụng phép OR, đặt bit tiếp theo từ bit_list vào vị trí trống vừa tạo. Sau 8 lần lặp, 8 bit sẽ được ghép lại thành 1 byte hoàn chỉnh


# thêm byte vừa tạo vào mảng byte_data đã tạo ở trên 
# chuyển mảng byte_data thành byte và trả về kết quả




   def _permute(self, data, p_table):
      # thuc hien hoan vi du lieu
      return [data [bit - 1] for bit in p_table]


# for bit in p_table   duyệt qua từng giá trị trong bảng hoán vị 
#  data [bit - 1]     lấy bit từ data đầu vào tại vị trí được chỉ định bởi các giá trị bit. phải trừ đi 1 vì các bảng hoán vị trong DES được đánh từ 0 trong khi index của list python bắt đầu từ 0

# [  ]  lấy toàn bộ các bit ra tạo thành 1 list mới theo thứ tự của p_table







   def _feistel_function(self, right, subkey):
      # F (R, K)

      # Buoc 1: mo rong nua phai R0 tu 32 -> 48 bit
      expanded_right = self._permute(right, E)

      # Buoc 2: XOR nua mo rong voi khoa con
      xor_result = [ a ^ b for a, b in zip( expanded_right, subkey)]

      # Buoc 3: Ap dung S-box
      sbox_result = []
      for i in range (8):
        # chia 48 thanh 8 khoi 6 bit
        sbox_input = xor_result [ i * 6 : (i + 1) * 6]

        # lay chi so hang va cot tu 6 bit
        row = (sbox_input [0] << 1) | sbox_input[5]
        col = (sbox_input [1] << 3) | (sbox_input [2] << 2) | (sbox_input [3] << 1) | sbox_input [4]

        # chuyen gia tri S-box tuong ung
        val = S_BOXES[i] [row] [col]

        # chuyen gia tri thanh 4 bit va them vao ket qua
        sbox_result.extend([
                (val >> 3) & 1,
                (val >> 2) & 1,
                (val >> 1) & 1,
                val & 1
            ])


      # Buoc 4: Hoa vi P
      return self._permute(sbox_result, P)


# Nửa phải 32 bit R0 được đưa vào bảng tra E để mở rộng từ 32 -> 48 bit
# Dùng list comprehension để XOR 48 bit vừa mở rộng với khóa con 48 bit
   # zip( expanded_right, subkey) sử dụng hàm zip để ghép cặp từng bit của expand với subkeys thành các cặp a,b
   # a^b thì tại đây khi lấy ra từng tặp a và b ta xor cả 2 lại với nhau trên từng cặp bit

# tạo mảng sbox_result
# đi duyệt qua 8 S-box, 
# [ i * 6 : (i + 1) * 6] cắt sbox_result (48bit) thành 8 khối 6 bit
# ví dụ  khi i = 0, nó cắt từ 0*6 đến 1*6 tức [0:6] lấy 6 bit đầu tiên


# row = (sbox_input [0] << 1) | sbox_input[5] xác định chỉ số hành 
  # với [0] lấy bit đầu tiên của khối 6 bit
  # với [5] lấy bit cuối cùng của khối 6 bit
  # với << ta sẽ dịnh bit đầu tiên sang trái 1 vị trí
  # | OR kết hợp bit đầu với bit cuối lại với nhau: ví dụ 11 =0011, 10 = 0010 chuyển sang thập phân trong bảng chỉ lấy hàng từ 0 - 3
  
# col tương tự như trên nó xác định chỉ số cột
    # Lấy 4 bit ở giữa [1] và [4]
    # dịch trái từng bit với vị trí tương ứng (<<3 , <<2,  <<1) với OR tất cả lại để tạo thành 4 bit
    # ví dụ như 1101  (1<<3) | (1<<2) | (0<<1) | 1  -> 8 | 4 | 0 | 1 = 13 thì cột thứ 13
    
    

# val = S_BOXES[i] [row] [col]
    # S_BOX lấy danh sách chứ 8 bảng SBOX
    # [i] chọn ra SBOX thứ i
    # [row] [col] truy cập vào bảng s-box để lấy đúng chỉ số hàng và cột vừa tính được để lất giá trị ra 
    
    

# sbox_result dòng này chuyển val (0-15) trở lại 4 bit và thêm vào sbox_reult
  # val >> 3 & 1: lấy vị trí thứ 4 (MSB)
  # .....
  # val & 1: lấy bit thứ 1 (LSB)
  
  # dùng extend thêm cả 4 bit này vào cuối danh sách sbox_result. sau 8 vòng lặp, nó sẽ có đủ 32 bit
  
  
# Cuối cùng áp dụng sbox_result vào bảng P (32) để trả về kết quả 









   def _generate_subkeys(self):
      # tao 16 khoa con
      # buoc 1: hoan vi khoa bang PC1
      key_permute = self._permute(self.key, PC1)

      # Buoc 2: chia khoa thanh C va D
      C = key_permute[:28]
      D = key_permute[28:]

      subkeys = []
      for i in range (16):
         # Buoc 3: dich vong hai nua C va D theo so bit da dinh
         shift = SHIFT_BITS[i]
         C = C[shift:] + C[:shift]
         D = D[shift:] + D[:shift]


         # Buoc 4: Hoan vi C va D bang PC2 de tao khoa con
         combined = C + D
         subkey = self._permute(combined, PC2)
         subkeys.append(subkey)

      return subkeys



# Áp dựng bảng hóa vị PC1 cho khóa (64-bit) để loại bỏ các bit chẳn lẻ và chỉ giữa lại 56 bit có nghĩa
# chia kết quả thu được làm 2 với C có 28bit và D có 28bit
# tạo mã subkey để chứa khóa con

# với i duyệt qua 16 vòng tương ứng tạo 16 khóa con
# SHIFT_BITS[i] lấy chỉ số bit cần dịch của vòng hiện tại từ bảng
# C = C[shift:] + C[:shift]: thực hiện phép dịch trái vòng, cắt list C từ vị trí shifft đến cuối tương tự cho D
# C + D đã dịch ghép lại nháu đê thành 1 list 56 bit

# áp dụng kết quả vừa ghép trên qua bảng PC2 để đưa 56 bit xuống thành 48 bit tạo thành khóa con vòng này
# Thêm khóa con vừa tạo vào danh sách subkeys





















   def encrypt_block (self, plaintext_block):
      # Ma hoa khoi 64 bit

      # Buoc 1: Hoan vi IP
      data = self._to_binary_list(plaintext_block, 64)
      permuted_data = self._permute(data, IP)

      # Buoc 2: chia khoi thanh 2 nua L va R
      left = permuted_data[:32]
      right = permuted_data[32:]

      # Buoc 3: thuc hien 16 vong
      for i in range(16):
        # luu lai nua trai cu
        temp_left = left

        # tinh toan nua trai moi
        left = right

        # tinh toan nua phai moi
        f_result = self._feistel_function(right, self.subkeys[i])
        right = [ a ^ b for a, b in zip(temp_left, f_result)]

      # hoan vi doi vi tri cuoi cung khi ket thuc
      combined = right + left

      # buoc 4: hoa vi ket thuc FP
      ciphertext_bits = self._pFPermute(combined, FP)


      return self._from_binary_list(ciphertext_bits)  # chuyển list_bit sang bytes trả về kết quả


# chuyển bản rõ thành 1 khối 64bit
# áp dụng bảng IP lên khối vừa chuyển 
# chia làm 2 nữa mỗi bên L = 32 R = 32
# Bắt đầu 16 vòng lặp

# tạo 1 logic lưu nữa bên trái cũ
# nữa trái mới L1 = R0
# Tính kết quả hàm F, sử dụng R0 với khóa i
# Nửa phải mới R1 = L0 XOR F

# R1 + L0








   def decrypt_block(self, ciphertext_block):
      # giai ma mot khoi 64 bit

      # buoc 1:  Hoa vi IP
      data = self._to_binary_list(ciphertext_block, 64)
      permuted_data = self._permute(data, IP)

      left = permuted_data[:32]
      right = permuted_data[32:]

      # buoc 3: thuc hien 16 vong
      for i in range (15, -1, -1):
        tmp_left = left   # L16
        left = right  # L15 = R16
        
        # tính R new (R15)
        f_result = self._feistel_function(right, self.subkeys[i]) 
        right = [ a ^ b for a,b in zip(tmp_left, f_result)]

      # Dao vi tri cuoi cung truoc khi ket thuc
      combined = right + left

      # buoc 4: hoan vi ket thuc FP
      decrypted_data = self._permute(combined, FP)

      return self._from_binary_list(decrypted_data)


















class TripleDES:
    # Khởi tạo 3 khóa riêng
    
  def __init__ (self, key1, key2, key3):
    self.des1 = DES(key1)
    self.des2 = DES(key2)
    self.des3 = DES(key3)

  def encrypt(self, plaintext):
      
     # Bước 1: Mã hóa bản rõ với des1 (key 1) 
    step1 = self.des1.encrypt_block(plaintext)
    
    
    # Bước 2: Giải mã kêt quả bước 1 với key2
    step2 = self.des2.decrypt_block(step1)
    
    
    # Bước 3: Mã hóa kết quả bước 2 với key 3
    ciphertext = self.des3.encrypt_block(step2)
    return ciphertext





  def decrypt(self, ciphertext):
    # Bước 1: Giải mã (Decrypt) bản mã bằng cỗ máy des3 (dùng key3).
    step1 = self.des3.decrypt_block(ciphertext)
        
    # Bước 2: Mã hóa (Encrypt) kết quả của bước 1 bằng cỗ máy des2 (dùng key2).
    step2 = self.des2.encrypt_block(step1)
        
    # Bước 3: Giải mã (Decrypt) kết quả của bước 2 bằng cỗ máy des1 (dùng key1)
    # để ra lại bản rõ ban đầu.        
    plaintext = self.des1.decrypt_block(step2)
        
    return plaintext














key1 = b'12345678'
key2 = b'abcdefgh'
key3 = b'IJKLMNOP'


plaintext = b'12345678'

triple_des_cipher = TripleDES(key1, key2, key3)
ciphertext = triple_des_cipher.encrypt(plaintext)
print(f"Ban ro: {plaintext.hex()}")
print(f"Ban ma: {ciphertext.hex()}")



decrypted_text = triple_des_cipher.decrypt(ciphertext)
print(f"Giai ma: {decrypted_text.hex()}")
print(f"Khop ban ro: {decrypted_text == plaintext}")



